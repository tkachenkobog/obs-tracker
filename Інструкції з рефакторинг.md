

---

### Промт для ChatGPT / іншої мовної моделі

**Завдання:** Провести рефакторинг коду плагіна для Obsidian, написаного на Svelte і TypeScript. Мета — покращити архітектуру, розділивши відповідальність між компонентами та винісши логіку роботи з файловою системою в окремий сервісний шар.

**Поточна ситуація:**  
Зараз вся логіка, включно з читанням та записом даних у JSON-файл, знаходиться безпосередньо в компоненті Calendar.svelte. Це робить його негнучким та важким для перевикористання.

**Що потрібно зробити:**

1. **Створити сервісний клас DataManager.ts:**
    
    - Цей клас має відповідати за всю взаємодію з файловою системою Obsidian (app.vault.adapter).
        
    - Він повинен мати методи для завантаження (load()) та збереження (save()) даних в один централізований JSON-файл.
        
    - Шлях до файлу даних має передаватися в конструктор, щоб його можна було налаштувати.
        
    - Клас повинен мати методи для отримання та оновлення окремих частин даних (наприклад, getHabits(), updateHabits(newHabits)), які будуть оперувати даними в пам'яті та викликати save() для персистенції.
        
2. **Модифікувати головний файл плагіна main.ts:**
    
    - Ініціалізувати DataManager один раз при завантаженні плагіна (onload).
        
    - Завантажувати дані з файлу один раз при старті (dataManager.load()).
        
    - Передавати екземпляр DataManager в MySvelteView, а звідти — як prop в кореневий Svelte-компонент rightSideBar.svelte.
        
3. **Рефакторинг rightSideBar.svelte:**
    
    - Зробити його "розумним" компонентом-контейнером.
        
    - Він має отримувати dataManager як prop.
        
    - При монтуванні (onMount) він повинен отримувати дані зі звичками з dataManager.getHabits().
        
    - Він має передавати в Calendar.svelte тільки необхідні для відображення дані — масив вибраних дат (selectedDates).
        
    - Він повинен слухати подію datesChanged від календаря, приймати новий масив дат і викликати dataManager.updateHabits() для збереження змін.
        
4. **Рефакторинг Calendar.svelte:**
    
    - Зробити його "тупим" презентаційним компонентом.
        
    - **Видалити** з нього будь-яку логіку, пов'язану з app, читанням/записом файлів (loadHabits, saveHabits).
        
    - Він має приймати масив вибраних дат (selectedDates: Date[]) як prop.
        
    - При кліці на день він не повинен нічого зберігати. Замість цього він має формувати новий масив вибраних дат і **емітити подію datesChanged**, передаючи в detail цей новий масив.
        

**Ось поточний код:**

**1. main.ts (точка входу):**

Generated typescript

```
// [Вставити сюди повний код файлу main.ts з користувацького запиту]
```

content_copydownload

Use code [with caution](https://support.google.com/legal/answer/13505487).TypeScript

**2. ui/rightSideBar.svelte (компонент-контейнер):**

Generated html

```
<!-- [Вставити сюди повний код файлу rightSideBar.svelte з користувацького запиту] -->
```

content_copydownload

Use code [with caution](https://support.google.com/legal/answer/13505487).Html

**3. ui/Calendar.svelte (компонент календаря з логікою):**

Generated html

```
<!-- [Вставити сюди повний код файлу Calendar.svelte з користувацького запиту] -->
```

content_copydownload

Use code [with caution](https://support.google.com/legal/answer/13505487).Html

**Кінцевий результат:**  
Чиста, масштабована архітектура, де DataManager керує даними, rightSideBar керує станом, а Calendar лише відображає дані та повідомляє про дії користувача. Надай мені оновлений код для всіх трьох файлів (main.ts, rightSideBar.svelte, Calendar.svelte) та код для нового файлу DataManager.ts.

thumb_upthumb_down13.9s

arrow_upward_altarrow_downward_alt
**Кінцевий результат:**  
Чиста, масштабована архітектура, де DataManager керує даними, rightSideBar керує станом, а Calendar лише відображає дані та повідомляє про дії користувача. Надай мені оновлений код для всіх трьох файлів (main.ts, rightSideBar.svelte, Calendar.svelte) та код для нового файлу DataManager.ts.